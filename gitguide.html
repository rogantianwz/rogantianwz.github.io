<h2 id="git-command-help">git command –help</h2>



<h2 id="git-config">git config</h2>

<ol>
<li><code>git config &lt;section.key&gt; value</code> , <code>git config --system user.name rogantian</code></li>
<li><code>git config &lt;section.key&gt;</code> , <code>git config --system user.name</code></li>
<li><code>git config --global --list</code></li>
<li><code>git config --local --edit</code></li>
<li><code>git config --unset user.name</code></li>
<li><code>git config --global alias.ps push</code></li>
<li><code>GIT_CONFIG=test.ini git config a.b.c "hello, world"</code></li>
</ol>



<h2 id="git-init">git init</h2>

<ol>
<li><code>git init</code></li>
<li><code>git init demo</code></li>
<li><code>git init demo2 --separate-git-dir &lt;pathspec&gt;</code></li>
</ol>



<h2 id="git-status">git status</h2>

<ol>
<li><code>git status -s</code></li>
<li><code>git status -s -b</code></li>
</ol>



<h2 id="git-rev-parse">git rev-parse</h2>

<ol>
<li><code>git rev-parse --git-dir</code></li>
<li><code>git rev-pase --show-toplevel</code></li>
<li><code>git rev-parse --show-prefix</code></li>
<li><code>git rev-parse --show-cdup</code></li>
<li><code>git rev-parse master</code>, <code>git rev-parse refs/heads/master</code>, <code>git rev-parse HEAD</code>的输出都是表示同一个引用的commitId</li>
</ol>



<h2 id="git-add">git add</h2>

<ol>
<li><code>git add -- &lt;pathspec&gt;</code> add files, fileglobs or direcotry</li>
<li><code>git add .</code>  stages new and modified, without deleted</li>
<li><code>git add -u</code> stages modified and deleted, without new. -u means update</li>
<li><code>git add -A</code> stages All. <code>git add -A = git add . + git add -u</code></li>
</ol>



<h2 id="git-commit">git commit</h2>

<ol>
<li><code>git commit --allow-empty</code></li>
<li><code>git commit --amend --allow-empty --reset-author</code></li>
</ol>



<h2 id="git-log">git log</h2>

<ol>
<li><code>git log --pretty=fuller</code></li>
<li><code>git log -2 --stat</code></li>
<li><code>git log --pretty=oneline</code></li>
</ol>



<h2 id="head">HEAD</h2>

<p>版本库中的最后一次提交, 在.git/HEAD文件中记录了其所指向的那个提交 <br>
1. <code>HEAD^</code> 表示版本库中的上一次提交,即HEAD的父提交 <br>
2. <code>HEAD^^</code> 表示HEAD^的父提交 <br>
3. <code>HEAD^2</code> 表示HEAD的第2个父提交 <br>
4. <code>HEAD~3</code> 表示第三代祖先 同 <code>HEAD^^^</code> <br>
5. <code>HEAD^{tree}</code> 表示HEAD提交所对应的树对象 <br>
6. <code>HEAD:path/to/file</code> 表示HEAD提交对应的文件对象 <br>
7. <code>:path/to/file</code> 表示暂存区中的文件对象</p>



<h2 id="git-branch">git branch</h2>

<p>每一个本地分支都会对应一个文件,在.git/refs/heads/目录下,该文件记录了该分支所指向的最近一个提交,可以使用<code>git rev-parse master</code> 和 <code>cat .git/refs/heads/master</code> 来验证, 可以用本地分支的分支名<code>refs/heads/master</code> 或 其缩写 <code>master</code> 来代表一个提交</p>



<h2 id="git-diff">git diff</h2>

<ol>
<li><code>git diff</code> 将当前共工作区同暂存区比较</li>
<li><code>git diff &lt;commit&gt;</code> 将当前工作区同提交比较, 如: <code>git diff HEAD</code> 表示当前工作区同头指针比较</li>
<li><code>git diff --cached &lt;commit&gt;</code> 使用–cached或者–staged表示讲暂存区同提交比较,如: <code>git diff --cached HEAD</code></li>
<li><code>git diff &lt;commit&gt; &lt;commit&gt;</code></li>
<li><code>git diff &lt;commit&gt;..&lt;commit&gt;</code> </li>
</ol>



<h2 id="git-difftool">git difftool</h2>

<ol>
<li><code>git difftool --extcmd icdiff</code></li>
</ol>



<h2 id="git-checkout">git checkout</h2>

<blockquote>
  <p><code>git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;</code> 如果没有指定<code>&lt;tree-ish&gt;</code>则从暂存区恢复文件到工作区,如果指定了<code>&lt;tree-ish&gt;</code>则从指定提交恢复文件到暂存区,然后再恢复到工作区 <code>&lt;treeish&gt;/&lt;commit&gt;</code> defaults to Index</p>
</blockquote>

<ol>
<li><code>git checkout --filename</code> 用暂存区中filename文件来覆盖工作区的filename文件,相当于取消了自上次执行 <code>git add filename</code> 以来本地的修改</li>
<li><code>git checkout .</code> 会用暂存区全部的文件替换工作区的文件,但是不影响未跟踪文件. </li>
<li><code>git checkout HEAD .</code> 会用HEAD指向的目录树替换暂存区和工作区. </li>
<li><code>git checkout branch --filename</code> 使用branch所指向的提交中的filename替换暂存区和工作区的相应文件,注意会将暂存区和工作区的filename文件直接覆盖掉</li>
</ol>

<blockquote>
  <p><code>git checkout branch</code> 切换分支</p>
</blockquote>

<ol>
<li><code>git checkout master</code> 切换到master分支</li>
</ol>

<blockquote>
  <p><code>git checkout &lt;commit&gt;</code> 暂存区和工作区都切换到commit,进入<code>头指针分离状态|DETACHED HEAD</code> 此时HEAD不再指向某个branch,而是一个commit</p>
</blockquote>



<h2 id="git-reset">git reset</h2>

<blockquote>
  <p><code>git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</code> set the current branch head (HEAD) to <code>&lt;commit&gt;</code>, optionally modifying index and working tree to &gt;match.The <code>&lt;tree-ish&gt;/&lt;commit&gt;</code> defaults to HEAD</p>
  
  <blockquote>
    <p><code>--soft</code> Does not touch the index file nor the working tree at all (but resets the head to <code>&lt;commit&gt;</code>, just like all modes do). 只影响HEAD的指向,不影响index和working <br>
    <code>--mixed</code> Default action 影响HEAD指向以及index <br>
    <code>--hard</code> Resets the index and working tree. Any changes to tracked files in the working tree since <code>&lt;commit&gt;</code> are discarded. 影响HEAD,index,working</p>
  </blockquote>
</blockquote>

<ol>
<li><code>git reset HEAD</code> 使用HEAD指向的目录树覆盖暂存区,相当于将之前用<code>git add</code> 命令更新到暂存去的内容撤出暂存区</li>
<li><code>git reset --hard HEAD^</code> 使HEAD指向其父提交,并且同步修改index和working,此操作会破会未提交的改动. 此操作几乎不可恢复</li>
</ol>

<blockquote>
  <p><code>git reset [-q] [tree-ish] [--] &lt;paths&gt;...</code> 使用指定<code>tree-ish</code> 提交状态下的文件 <code>&lt;paths&gt;</code> 替换掉暂存区中的文件. This means that git reset <code>&lt;paths&gt;</code> is the opposite of git add <code>&lt;paths&gt;</code>. </p>
</blockquote>

<ol>
<li><code>git reset -- filename</code> 仅将文件filename的改动撤出暂存区,暂存区中其他文件不改变.相当于对命令<code>git add filename</code> 的反向操作</li>
</ol>



<h2 id="git-reflog">git reflog</h2>

<ol>
<li><code>git reflog show master</code> 显示master分支的reflog记录</li>
</ol>



<h2 id="git-rm">git rm</h2>

<ol>
<li><code>git rm --cached &lt;file&gt;</code> 直接从暂存区删除文件</li>
</ol>



<h2 id="git-clean">git clean</h2>

<ol>
<li><code>git clean -d</code> 清除工作区中未跟踪的目录和文件</li>
<li><code>git clean -n</code> 演习</li>
</ol>



<h2 id="git-ls-tree">git ls-tree</h2>



<h2 id="git-ls-files">git ls-files</h2>

<ol>
<li><code>git ls-files</code> 显示index中缓存的文件</li>
<li><code>git ls-files --modified</code> 显示工作区中修改过的文件</li>
</ol>



<h2 id="git-ls-tree-1">git ls-tree</h2>

<p>显示树的内容 <br>
1. <code>git ls-tree HEAD</code> 显示HEAD指向的tree object</p>



<h2 id="git-cat-file">git cat-file</h2>

<p>Provide content or type and size information for repository objects <br>
1. <code>git cat-file -t &lt;objct&gt;</code> Instead of the content, show the object type identified by <code>&lt;object&gt;</code> <br>
2. <code>git cat-file -p &lt;objcet&gt;</code> Pretty-print the contents of <code>&lt;object&gt;</code> based on its type. <br>
3.  <code>git cat-file -s &lt;object&gt;</code> Instead of the content, show the object size identified by <code>&lt;object&gt;</code></p>



<h2 id="git-log-1">git log</h2>

<ol>
<li><code>git log --pretty[=online|raw...]</code></li>
<li><code>git log --graph</code></li>
</ol>



<h2 id="git-push">git push</h2>

<ol>
<li><code>git push -u origin master</code> 将本地分支推送到名为origin的库的master分支上去,并且将该分支与origin的master分支绑定,以后在本地可以直接使用<code>git push</code> 或者 <code>git pull</code> 而无需指定仓库和分支名. <code>-u</code> 是 <code>--set-upstream</code> 的缩写</li>
</ol>

<blockquote>
  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>
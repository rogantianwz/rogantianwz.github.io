<h2 id="同步-异步-阻塞-非阻塞">同步 异步 阻塞 非阻塞</h2>

<blockquote>
  <p>同步异步指的是用户进程与系统之间的交互方式; 阻塞非阻塞是用户进程的两个状态. <br>
  同步: 用户触发IO操作后等待或者轮询IO是否就绪 <br>
  异步: 用户触发IO操作后就不管了,系统在IO就绪后会通知用户 <br>
  同步阻塞  同步非阻塞  异步阻塞  异步非阻塞</p>
</blockquote>



<h2 id="bio">BIO</h2>

<ol>
<li>示例</li>
<li>优点</li>
<li>缺点: 服务端的线程个数和客户端并发访问数呈1：1的正比关系，当线程数膨胀之后，系统的性能将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务</li>
</ol>



<h2 id="facknio">FackNIO</h2>

<ol>
<li><a href="http://s.rogantian.com/img/facknio.png">示例</a></li>
<li>优点: 无论客户端并发连接数多大，它都不会导致线程个数过于膨胀或者内存溢出，相比于传统的一连接一线程模型，是一种改良。</li>
<li>缺点: 避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。由于线程池采用阻塞队列实现，当队列积满之后，后续入队列的操作将被阻塞 。由于它底层的通信依然采用同步阻塞模型，因此无法从根本上解决问题。</li>
</ol>



<h2 id="nio">NIO</h2>

<ol>
<li><a href="http://blog.csdn.net/baple/article/details/12749005">缓冲区Buffer</a></li>
<li><a href="http://book.51cto.com/art/201407/444916.htm">Channel</a></li>
<li><p>Selector</p>

<blockquote>
  <p>a. 创建 <code>Selector selector = Selector.open();</code> <br>
  b. 注册 <code>channel.register(selector,Selectionkey.OP_READ);</code>  <br>
  <code>SelectionKey.OP_CONNECT</code> <code>SelectionKey.OP_ACCEPT</code> <code>SelectionKey.OP_READ</code> <code>SelectionKey.OP_WRITE</code> 或操作 <br>
  c. 轮询 <code>int selected = selector.select()</code> <br>
  d. ready集合 <code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</code> <br>
  e. 添加附加对象 <code>channel.register(selector, SelectionKey.OP_READ, theObject);</code> <br>
  f. 获取附加对象 <code>selectionKey.attachment();</code></p>
</blockquote></li>
<li><p><a href="http://s.rogantian.com/img/nio.png">示例</a></p></li>
<li>优点:</li>
</ol>

<h2 id="aio">AIO</h2>



<h2 id="netty">Netty</h2>

<ol>
<li><a href="http://s.rogantian.com/img/netty-reactor.jpg">模型</a></li>
<li>示例</li>
<li>半包，粘包，自定义协议</li>
<li>优点：简单，门槛低；预置各种编解码器；可定制性很高；得到广泛认可。</li>
</ol>

<blockquote>
  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote>